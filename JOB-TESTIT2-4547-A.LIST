                        TTTTTTTTTTTT  EEEEEEEEEEEE   SSSSSSSSSS   TTTTTTTTTTTT   IIIIIIIIII   TTTTTTTTTTTT   2222222222
                       TTTTTTTTTTTT  EEEEEEEEEEEE  SSSSSSSSSSSS  TTTTTTTTTTTT   IIIIIIIIII   TTTTTTTTTTTT  222222222222
                           TT       EE            SS        SS       TT            II            TT       22        22
                          TT       EE            SS                 TT            II            TT                 22
                         TT       EE            SSS                TT            II            TT                 22
                        TT       EEEEEEEE       SSSSSSSSS         TT            II            TT                22
                       TT       EEEEEEEE        SSSSSSSSS        TT            II            TT              22
                      TT       EE                     SSS       TT            II            TT            22
                     TT       EE                      SS       TT            II            TT          22
                    TT       EE            SS        SS       TT            II            TT        22
                   TT       EEEEEEEEEEEE  SSSSSSSSSSSS       TT        IIIIIIIIII        TT       222222222222
                  TT       EEEEEEEEEEEE   SSSSSSSSSS        TT        IIIIIIIIII        TT       222222222222



                    JJJJJJJJJJ        444     555555555555        444     777777777777                 AAAAAAAAAA
                    JJJJJJJJJJ       4444     555555555555       4444     77777777777                 AAAAAAAAAAAA
                        JJ          44 44     55                44 44     77      77                  AA        AA
                        JJ         44  44     55               44  44            77                   AA        AA
                        JJ        44   44     55              44   44           77                    AA        AA
                        JJ       44444444444  555555555      44444444444       77                     AAAAAAAAAAAA
                        JJ      444444444444  5555555555    444444444444       77                     AAAAAAAAAAAA
                        JJ             44              55          44          77                     AA        AA
                  JJ    JJ             44               55         44          77                     AA        AA
                  JJ    JJ             44               55         44          77                     AA        AA
                  JJJJJJJJ             44     555555555555         44          77                     AA        AA
                   JJJJJJ              44     55555555555          44          77                     AA        AA


****A  START  JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547  START  A****
****A  START  JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547  START  A****
****A  START  JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547  START  A****
****A  START  JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547  START  A****
                                                J E S 2   J O B   L O G


09.02.43 JOB 4547  $HASP373 TESTIT2  STARTED - INIT  2 - CLASS A - SYS TK4-
09.02.43 JOB 4547  IEF403I TESTIT2 - STARTED - TIME=09.02.43
09.02.43 JOB 4547  IEFACTRT - Stepname  Procstep  Program   Retcode
09.02.43 JOB 4547  TESTIT2    S2                  PDSUNLDP  RC= 0000
09.02.43 JOB 4547  IEF404I TESTIT2 - ENDED - TIME=09.02.43
09.02.43 JOB 4547  $HASP395 TESTIT2  ENDED


------ JES2 JOB STATISTICS ------


 06 APR 23 JOB EXECUTION DATE


        10 CARDS READ


       726 SYSOUT PRINT RECORDS


         0 SYSOUT PUNCH RECORDS


      0.00 MINUTES EXECUTION TIME
    1     //TESTIT2 JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1),NOTIFY=HERC01,          JOB 4547
          //    USER=HERC01,PASSWORD=
          ***
    2     //S2   EXEC PGM=PDSUNLDP
    3     //STEPLIB DD DSN=HERC01.PDSUTIL.LOADLIB,DISP=SHR
    4     //        DD DSN=SYS1.PL1LIB,DISP=SHR
    5     //SYSPRINT DD SYSOUT=*
    6     //PDSIN    DD DSN=HERC01.PDSUTIL.PLI,DISP=SHR
    7     //CARDOUT  DD SYSOUT=*,DCB=BLKSIZE=80
          ***
IEF236I ALLOC. FOR TESTIT2 S2
IEF237I 240  ALLOCATED TO STEPLIB
IEF237I 148  ALLOCATED TO
IEF237I 240  ALLOCATED TO SYS00002
IEF237I JES2 ALLOCATED TO SYSPRINT
IEF237I 240  ALLOCATED TO PDSIN
IEF237I JES2 ALLOCATED TO CARDOUT
IEF142I TESTIT2 S2 - STEP WAS EXECUTED - COND CODE 0000
IEF285I   HERC01.PDSUTIL.LOADLIB                       KEPT          *--------0
IEF285I   VOL SER NOS= PUB000.
IEF285I   SYS1.PL1LIB                                  KEPT          *--------0
IEF285I   VOL SER NOS= MVSRES.
IEF285I   SYS1.UCAT.TSO                                KEPT          *--------0
IEF285I   VOL SER NOS= PUB000.
IEF285I   JES2.JOB04547.SO0101                         SYSOUT
IEF285I   HERC01.PDSUTIL.PLI                           KEPT          *------142
IEF285I   VOL SER NOS= PUB000.
IEF285I   JES2.JOB04547.SO0102                         SYSOUT
IEF373I STEP /S2      / START 23096.0902
IEF374I STEP /S2      / STOP  23096.0902 CPU    0MIN 00.04SEC SRB    0MIN 00.01SEC VIRT    56K SYS   196K
************************************************************************************************************************************
*     1. Jobstep of job: TESTIT2     Stepname: S2          Program name: PDSUNLDP   Executed on 06.04.23 from 09.02.43 to 09.02.43 *
*         elapsed time  00:00:00,23                      CPU-Identifier:  TK4-           Page-in:      0                           *
*             CPU time  00:00:00,05               Virtual Storage used:     56K         Page-out:      0                           *
*           corr. CPU:  00:00:00,05   CPU time has been corrected by  1 / 1,0  multiplier                                          *
*                                                                                                                                  *
*     I/O Operation                                                                                                                *
*     Number of records read via DD * or DD DATA:      0                                                                           *
*     240.......0 148.......0 240.......0 DMY.......0 240.....142 DMY.......0                                                      *
*                                                                                                                                  *
*                                          Charge for step (w/o SYSOUT):          0,08                                             *
************************************************************************************************************************************
IEF375I  JOB /TESTIT2 / START 23096.0902
IEF376I  JOB /TESTIT2 / STOP  23096.0902 CPU    0MIN 00.04SEC SRB    0MIN 00.01SEC
PDSUNLDP V1.2.0                                                                                              PAGE   1
MEMBER    USERID  CREATED    UPDATED      TIME   COMMENTS

DATECNVP            END OF MEMBER (RC=4)   36 RECORDS READ
GETPDSPA            END OF MEMBER (RC=4)  114 RECORDS READ
PDSCANR             END OF MEMBER (RC=4)  279 RECORDS READ
PDSUNLDP            END OF MEMBER (RC=4)  230 RECORDS READ

END OF DIRECTORY (RC=4)
MEMBER PROCESSED=         4

PDSUNLDP V1.2.0 ENDED
./  ADD NAME=DATECNVP
     /******************* DATECNVP V1.0.0 *****************************
      *****************************************************************
      *                                                               *
      * NAME: DATECNVP - PARM LIST DEFINITIONS FOR DATECNV            *
      *                                                               *
      * NOTE: THERE IS A COBOL VERSION OF THIS.  THEY SHOULD BE KEPT  *
      *       IN SYNC.                                                *
      *                                                               *
      *****************************************************************
      *                                                               *
      *  (C) COPYRIGHT 2023 EDWARD G LISS   ALL RIGHTS RESERVED       *
      *                                                               *
      *  THIS SOURCE CODE AS WELL AS ANY OBJECT CODE RESULTING FROM   *
      *  THIS SOURCE CODE MAY BE DISTRIBUTED FREELY PROVIDED NO FEE   *
      *  IS CHARGED AND FOR NON-COMERCIAL PURPOSES.                   *
      *                                                               *
      *  FOR COMMERCIAL DISTRIBUTION RIGHTS, CONTACT THE COPYRIGHT    *
      *  OWNER.                                                       *
      *                                                               *
      *****************************************************************
      *                                                               *
      * REVISION HISTORY                                              *
      * ------  ----------------------------------------------------- *
      * V1.1.0  INITIAL VERSION.                                      *
      *                                                               *
      ****************************************************************/

      DECLARE
        1  DATECNV_PARM               STATIC,
           5  DC_RETURN_CODE          FIXED BINARY(31),
           5  DC_INPUT_FORMAT         CHAR(8),
           5  DC_INPUT_DATE           CHAR(10),
           5  DC_OUTPUT_FORMAT        CHAR(8),
           5  DC_OUTPUT_DATE          CHAR(10);

      /****************** DATECNVP V1.0.0  END ***********************/
./  ADD NAME=GETPDSPA
 /********************** GETPDSPA V1.2.0 ******************************/
 /*********************************************************************/
 /*                                                                   */
 /* NAME: GETPDSPA - PARM LIST DEFINITIONS FOR GETPDS V1.3.0          */
 /*                                                                   */
 /* NOTE: THERE IS A COBOL VERSION OF THIS.  THEY SHOULD BE KEPT      */
 /*       IN SYNC.                                                    */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*  (C) COPYRIGHT 2017 EDWARD G LISS   ALL RIGHTS RESERVED           */
 /*  (C) COPYRIGHT 2023 EDWARD G LISS   ALL RIGHTS RESERVED           */
 /*                                                                   */
 /*  THIS SOURCE CODE AS WELL AS ANY OBJECT CODE RESULTING FROM THIS  */
 /*  SOURCE CODE MAY BE DISTRIBUTED FREELY PROVIDED NO FEE IS CHARGED */
 /*  AND FOR NON-COMERCIAL PURPOSES.                                  */
 /*                                                                   */
 /*  FOR COMMERCIAL DISTRIBUTION RIGHTS, CONTACT THE COPYRIGHT OWNER. */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /* REVISION HISTORY                                                  */
 /* ------  --------------------------------------------------------  */
 /* V1.1.0  INITIAL VERSION.                                          */
 /* V1.2.0  ADDED THE DEFINITION OF MEMBERS STATS AND ADDED           */
 /*         WORK AREAS FOR STATISTICS CODE CONVERSION.                */
 /*                                                                   */
 /*********************************************************************/

     DECLARE
        1  PDSGET_PARAMETERS   STATIC ALIGNED,
            2  PDSGET_REQUEST_OPEN   INITIAL(0)  FIXED BINARY(31),
            2  PDSGET_REQUEST_START  INITIAL(1)  FIXED BINARY(31),
            2  PDSGET_REQUEST_LOCATE INITIAL(4)  FIXED BINARY(31),
            2  PDSGET_REQUEST_NEXT   INITIAL(5)  FIXED BINARY(31),
            2  PDSGET_REQUEST_READ   INITIAL(8)  FIXED BINARY(31),
            2  PDSGET_REQUEST_CLOSE  INITIAL(12) FIXED BINARY(31);
     DECLARE
        1   PDSGET_REQUEST_1      STATIC,
            2  PDSGET_REQUEST     FIXED BINARY(31),
        1   PDSGET_MEMBER_1       STATIC,
            2  PDSGET_MEMBER      CHAR(8),     /* DDNAME FOR OPEN */
        1   PDSGET_RECORD80_1     STATIC,
            2  PDSGET_RECORD80    CHAR(80),
        1   PDSGET_RETURN_CODE_1  STATIC,
            2  PDSGET_RETURN_CODE FIXED BINARY(31);
 /*********************************************************************/
 /*                                                                   */
 /* PDSGET_RETURN_CODE DEFINITIONS                                    */
 /*       RETURN_CODE 0 = SUCCESSFUL COMPLETION OF REQUEST            */
 /*       RETURN_CODE 8 = SERIOUS ERROR.                              */
 /*       RETURN_CODE 4 = DEPENDS ON REQUEST CODE                     */
 /*            REQUEST_CODE    MEANING                                */
 /*                  0         PDS COULD NOT BE OPENED.               */
 /*                  1         PDS COULD NOT BE OPENED.               */
 /*                  4         MEMBER NOT FOUND.                      */
 /*                  5         END OF DIRECTORY.                      */
 /*                  8         END OF CURRENT MEMBER.                 */
 /*                                                                   */
 /*********************************************************************/
     DECLARE
        PDSGET_PTR   POINTER,
        1  PDSGET_STATISTICS          BASED(PDSGET_PTR),
           2  PDS_C                      CHAR(1),
           2  PDS_VERSION                CHAR(1),
           2  PDS_MOD                    CHAR(1),
           2  PDS_NULL                   CHAR(2),
           2  PDS_DATE_CREATED           FIXED DECIMAL(7,0),
           2  PDS_DATE_UPDATED           FIXED DECIMAL(7,0),
           2  PDS_TIME_CHANGED_H         CHAR(1),
           2  PDS_TIME_CHANGED_M         CHAR(1),
           2  PDS_CURRENT_LINES          FIXED BINARY(15),
           2  PDS_INITIAL_LINES          FIXED BINARY(15),
           2  PDS_CHANGED_LINES          FIXED BINARY(15),
           2  PDS_USER_ID                CHAR(8);

      /*****************************************************************
       *                                                               *
       *   PDS-TIME-CHANGED -H AND -M ARE UNSIGNED PACKED DECIMALS     *
       *   THEY MUST TO CONVERTED TO SIGNED PACK DECIMAL TO USE THEM.  *
       *   THE PDS_TIME_CONVERSION FUNCTION CAN BE USED FOR THAT.      *
       *                                                               *
       *   THIS CONVERSION MUST TAKE PLACE FOR BOTH THE -H AND =M      *
       *   PDS-TIME-CHANGED- FIELDS.                                   *
       *                                                               *
       ****************************************************************/
     DECLARE PDS_TIME_CONVERSION ENTRY RETURNS(CHAR(2));
 PDS_TIME_CONVERSION:PROC(A_BYTE) RETURNS(CHAR(2));
     DECLARE A_BYTE             CHAR(1);
     DECLARE
           PDS_FILLER1_PTR      POINTER,
           PDS_FILLER4_PTR      POINTER,

           PDS_TIME_WORK        FIXED DECIMAL(5,0) INITIAL(0),

        1  PDS_FILLER1                  BASED(PDS_FILLER1_PTR),
                10  FILLER2             CHAR(1),
                10  PDS_TIME_CHAR       CHAR(1),
                10  FILLER3             CHAR(1),
        1  PDS_4_DIGIT_TIME             PIC '(4)9',
        1  FILLER4                      BASED(PDS_FILLER4_PTR),
                10  FILLER5             CHAR(1),
                10  PDS_TIME            CHAR(2),
                10  FILLER6             CHAR(1);

     PDS_FILLER1_PTR = ADDR(PDS_TIME_WORK);
     PDS_FILLER4_PTR = ADDR(PDS_4_DIGIT_TIME);

     PDS_TIME_WORK = 0;
     PDS_TIME_CHAR = A_BYTE;
     PDS_4_DIGIT_TIME = PDS_TIME_WORK;
     RETURN(PDS_TIME);
 END PDS_TIME_CONVERSION;
 /********************** GETPDSPA V1.2.0  END *************************/
./  ADD NAME=PDSCANR
 /********************** PDSCANR V1.1.1 *******************************/
 /*********************************************************************/
 /*                                                                   */
 /* NAME: PDSCANR - SCAN A PDS FOR GIVEN STRINGS.                     */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*  (C) COPYRIGHT 2023  EDWARD G LISS      ALL RIGHTS RESERVED       */
 /*                                                                   */
 /*  THIS SOURCE CODE AS WELL AS ANY OBJECT CODE RESULTING FROM THIS  */
 /*  SOURCE CODE MAY BE DISTRIBUTED FREELY PROVIDED NO FEE IS CHARGED */
 /*  AND FOR NON-COMERCIAL PURPOSES.                                  */
 /*                                                                   */
 /*  FOR COMMERCIAL DISTRIBUTION RIGHTS, CONTACT THE COPYRIGHT OWNER. */
 /*                                                                   */
 /*********************************************************************/
 /*                                                                   */
 /*   THIS PROGRAM READS ALL THE MEMBERS OF A PDS AND SCANS EACH      */
 /*   EACH RECORD FOR GIVEN STRINGS.  THE STRINGS ARE ENTERED VIA     */
 /*   THE SYSIN DD.  EACH STRING CAN BE UP TO 8 CHARACTERS AND MUST   */
 /*   BE ENCLOSED IN QUOTES (I.E. 'STRING').  STRINGS ARE SEPERATED   */
 /*   BY COMMAS.  NO SEQUENCE NUMBERS IN 73-80.                       */
 /*                                                                   */
 /*   THE PDS TO SCAN IS POINTED TO BY DDNAME PDSIN.                  */
 /*                                                                   */
 /*   AN EXEC PARM CAN BE GIVEN - THE DEFAULT OF ANY WILL PRINT       */
 /*   WHEN IT MATCHES ANY OF THE SEARCH STRINGS.  A PARM OF 'ALL'     */
 /*   WILL PRINT WHEN ALL THE STRINGS ARE FOUND IN A RECORD.          */
 /*                                                                   */
 /* REVISION HISTORY                                                  */
 /* ------  --------------------------------------------------------  */
 /* V1.0.0  NEW PROGRAM.  OCTOBER, 2012                               */
 /*                                                                   */
 /* V1.1.0  BUG FIX.  07/22/2020                                      */
 /*         PROBLEM:  FIRST RECORD OF EACH MEMBER WAS BEING SKIPPED.  */
 /*         BUG IN GETPDSP DID NOT RETURN 1ST RECORD ON 1ST CALL.     */
 /*                                                                   */
 /* V1.1.1  CLEAN UP. 03/31/2023                                      */
 /*         MODIFIED TO USE INCLUDES FOR PDSGET_PARAMETERS.           */
 /*         NO FUNCTIONAL CHANGES.                                    */
 /*                                                                   */
 /*********************************************************************/

 PDSCANR:PROCEDURE(EXEC_PARM) OPTIONS(MAIN);

     DECLARE EXEC_PARM            CHAR(100) VARYING;
     DECLARE LAST_MEMBER          CHAR(8) INITIAL((8)' ');
     DECLARE PAGE_CTR             INITIAL(0)    FIXED DECIMAL(5,0);
     DECLARE (ANY_OPTION,       INITIAL('0'B),
              ALL_OPTION        INITIAL('0'B))  BIT(1) ALIGNED;
     DECLARE
        1  WS_MEMBER_COUNT       FIXED BINARY(31) ALIGNED INITIAL(0);

     %INCLUDE GETPDSPA;

     DECLARE
        1   SCAN_STRS,
            2  SCAN_TBL_MAX       FIXED BINARY(15,0) INITIAL(0),
            2  SCAN_TBL(20),
               3  SCAN_STR        CHAR(8) VARYING,
               3  SCAN_CTR        FIXED DECIMAL(7,0);

     SCAN_STR(*)='';
     SCAN_CTR(*)=0;
     ON ENDPAGE(SYSPRINT)
     BEGIN;
        IF PAGE_CTR > 0 THEN PUT PAGE;
        PAGE_CTR=PAGE_CTR+1;
        PUT EDIT('PDSCANR V1.1.1','PAGE ',PAGE_CTR)
                     (A,COL(110),A,F(5));
        PUT SKIP(2);
        IF LAST_MEMBER = (8)' ' THEN;
        ELSE
        DO;
            PUT SKIP EDIT('MEMBER ',LAST_MEMBER,' (CONTINUED)')
               (A,A,A);
            PUT SKIP(2);
        END;
     END;
1    SIGNAL ENDPAGE(SYSPRINT);
     CALL P000_LOAD_STR;
     CALL P100_OPEN_PDS;
     CALL P600_CLOSE_PDS;

     PUT SKIP EDIT('MEMBER PROCESSED=',WS_MEMBER_COUNT)(A,F(10));
     DO I=1 TO SCAN_TBL_MAX;
        PUT SKIP LIST(SCAN_STR(I),'FOUND',SCAN_CTR(I));
     END;
     PUT SKIP LIST('PDSCANR CONCLUDED');

-P000_LOAD_STR:PROC;
     DECLARE WORK_STR  CHAR(8) VARYING;
     DECLARE E_O_F     BIT(1)  ALIGNED INITIAL('0'B);
     DECLARE I         FIXED BINARY ALIGNED;
     IF LENGTH(EXEC_PARM) = 0 THEN
     DO;
        PUT SKIP EDIT('NO EXEC PARM FOUND.  DEFAULTING TO ''ANY''')
            (A);
        ANY_OPTION='1'B;
     END;
     ELSE
     IF LENGTH(EXEC_PARM)=3 THEN
     DO;
        PUT SKIP EDIT('PARM=''',EXEC_PARM,'''') (A,A,A);
        IF EXEC_PARM = 'ANY' THEN ANY_OPTION='1'B;
        ELSE
           IF EXEC_PARM = 'ALL' THEN ALL_OPTION='1'B;
           ELSE
              PUT SKIP LIST('INVALID PARM');
     END;
     ELSE
        PUT SKIP LIST('INVALID PARM');
     PUT SKIP;
     ON ENDFILE(SYSIN)  E_O_F = '1'B;
     DO WHILE (E_O_F = '0'B);
        GET LIST(WORK_STR);
        IF E_O_F = '0'B THEN
        DO;
           IF LENGTH(WORK_STR)=0 THEN
           DO;
              PUT SKIP LIST('NULL SEARCH STRING IGNORED');
           END;
           ELSE
           DO;
              SCAN_TBL_MAX=SCAN_TBL_MAX+1;
              SCAN_STR(SCAN_TBL_MAX)=WORK_STR;
           END;
        END;
     END;
     IF SCAN_TBL_MAX=0 THEN
     DO;
         PUT SKIP LIST('NO STRINGS TO SCAN FOR');
         STOP;
     END;
     PUT SKIP LIST('THE FOLLOWING STRINGS WILL BE SEARCHED FOR');
     PUT SKIP(2) LIST(' ','STRING');
     DO I=1 TO SCAN_TBL_MAX;
        PUT SKIP LIST(I,SCAN_STR(I));
     END;
 END P000_LOAD_STR;
-P100_OPEN_PDS:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_OPEN;
     PDSGET_MEMBER  = 'PDSIN   ';
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
         CALL P200_START_DIR;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('OPEN FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('OPEN FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P100_OPEN_PDS;
-P200_START_DIR:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_START;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
         CALL P300_NEXT_DIR;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('START FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('START FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P200_START_DIR;
-P300_NEXT_DIR:PROC;
     PDSGET_RETURN_CODE = 0;
     DO WHILE(PDSGET_RETURN_CODE = 0);
         PDSGET_REQUEST = PDSGET_REQUEST_NEXT;
         CALL P900_CALL_GETPDSP;
         IF PDSGET_RETURN_CODE = 0 THEN
         DO;
             CALL P400_LOCATE_MEMBER;
             PDSGET_RETURN_CODE = 0;
         END;
         ELSE
         IF PDSGET_RETURN_CODE = 4 THEN
             PUT SKIP LIST('END OF DIRECTORY (RC=4)');
         ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                          'NEXT FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
     END; /* DO UNTIL */
 END P300_NEXT_DIR;
-P400_LOCATE_MEMBER:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_LOCATE;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
     DO;
      /* PUT SKIP LIST('MEMBER NAME=',PDSGET_MEMBER); */
         CALL P500_READ_MEMBER;
     END;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('MEMBER NOT FOUND (RC=4)');
     ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                       'LOCATE FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
 END P400_LOCATE_MEMBER;
-P500_READ_MEMBER:PROC;
     DECLARE I          FIXED BINARY ALIGNED,
             HIT_CNT    FIXED DECIMAL(7,0);
     PDSGET_REQUEST = PDSGET_REQUEST_READ;
 /************************************ V1.1.0 FIX START **************
     CALL P900_CALL_GETPDSP;
 ************************************* V1.1.0 FIX END   *************/
     WS_MEMBER_COUNT=WS_MEMBER_COUNT+1;
     IF PDSGET_RETURN_CODE = 0 THEN
     DO;
         DO WHILE (PDSGET_RETURN_CODE = 0);
            CALL P900_CALL_GETPDSP;
            IF PDSGET_RETURN_CODE = 0 THEN
            DO;
               HIT_CNT=0;
               DO I=1 TO SCAN_TBL_MAX;
                  IF INDEX(PDSGET_RECORD80,SCAN_STR(I))> 0 THEN
                  DO;
                     HIT_CNT=HIT_CNT+1;
                     SCAN_CTR(I)=SCAN_CTR(I)+1;
                  END;
               END;
               IF (ANY_OPTION & HIT_CNT > 0) |
                  (ALL_OPTION & HIT_CNT = SCAN_TBL_MAX) THEN
               DO;
                  IF LAST_MEMBER = PDSGET_MEMBER THEN;
                  ELSE
                  DO;
                     LAST_MEMBER = PDSGET_MEMBER;
                     PUT SKIP EDIT('MEMBER ',LAST_MEMBER)
                                             (A,A);
                  END;
                  PUT SKIP EDIT(PDSGET_RECORD80) (X(5),A);
            END;
         END;
     END;

     IF PDSGET_RETURN_CODE = 4 THEN
      /* PUT SKIP LIST('END OF FILE ON MEMBER (RC=4)') */;
     ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                       'READ FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
 END P500_READ_MEMBER;
-P600_CLOSE_PDS:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_CLOSE;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('CLOSE FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('CLOSE FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P600_CLOSE_PDS;
-P900_CALL_GETPDSP:PROC;
     CALL GETPDSP (PDSGET_REQUEST_1,
                   PDSGET_MEMBER_1,
                   PDSGET_RECORD80_1,
                   PDSGET_RETURN_CODE_1);
 END P900_CALL_GETPDSP;

 END PDSCANR;
./  ADD NAME=PDSUNLDP
 /************************ PDSUNLDP - PL/1 F VERSION *****************
       PROGRAM-ID. PDSUNLDP.
       AUTHOR. ED LISS.
       DATE-WRITTEN. MARCH, 2010.
       DATE-COMPILED.
       REMARKS. THIS PROGRAM READS A PDS AND WRITES EACH MEMBER WITH
            AN ./ ADD SUITABLE FOR RELOADING USING IEBUPDTX OR
            IEBUPDTE.  THE './ ADD NAME=XXXXXXXX' IS GENERATED FOR
            EACH MEMBER.  IF A EXEC_CARD PARM IS PASSED, THE PARM
            IS APPENDED I.E.  './ ADD NAME=XXXXXXXX,PARM'.  USING
            THE PARM ENABLES UTILITY CONTROL STATEMENTS FOR
            IEBUPDTE OR IEBUPDTX TO BE GENERATED.

            VERSION     DATE     COMMENTS
            -------   ---------  ---------------------------------
             1.0.0      03/2010  ORIGINAL VERSION
             1.1.0    06/17/2010 CHANGED SO ONLY NAME PARM
                                 IS GENERATED.  IF AN EXEC PARM
                                 IS PASSED, IT WILL BE ADDED TO
                                 THE ./ ADD NAME=,PARM
             1.2.0    03/19/2023 CODE CLEANUP AND ADDED ISPF/RPF
                                 STATS TO REPORT

 ********************************************************************/

 PDSUNLD:PROCEDURE(EXEC_PARM) OPTIONS(MAIN);

     DECLARE EXEC_PARM CHAR(100) VARYING;
     DECLARE CARD_FILE STREAM OUTPUT FILE;
     DECLARE
        1  WS_MEMBER_COUNT       FIXED BINARY(31) ALIGNED INITIAL(0);

 /*#INCLUDE GETPDSPA.PLI*/
   %INCLUDE GETPDSPA;
1
 /*#INCLUDE DATECNVP.PLI*/
   %INCLUDE DATECNVP;

     DECLARE NAME_WORK            CHAR(8),
             1 NAME_WORK_CHARS DEFINED NAME_WORK,
               2 NAME_WORK_CHAR(8) CHAR(1);
     DECLARE NAME_STR             CHAR(8) VARYING;
     DECLARE CHAR_INDEX           FIXED BINARY ALIGNED;
     DECLARE (PAGE_NUM,
              REC_COUNT)          FIXED BINARY ALIGNED
                                  INIT(0);
1    ON ENDPAGE(SYSPRINT)
     BEGIN;
        PAGE_NUM = PAGE_NUM + 1;
        PUT PAGE EDIT('PDSUNLDP V1.2.0','PAGE ',PAGE_NUM)
                     (A,COL(110),A,P'ZZ9');
        IF PAGE_NUM = 1 &
           LENGTH(EXEC_PARM)>0 THEN
              PUT SKIP EDIT(' WITH PARM=',EXEC_PARM) (A,A);
        PUT SKIP EDIT('MEMBER    USERID  CREATED    UPDATED      TIME',
                      '   COMMENTS') (A,A);
        PUT SKIP;
     END;
     SIGNAL ENDPAGE(SYSPRINT);
     OPEN FILE(CARD_FILE) OUTPUT TITLE('CARDOUT');
     CALL P100_OPEN_PDS;
     CALL P600_CLOSE_PDS;

     PUT SKIP EDIT('MEMBER PROCESSED=',WS_MEMBER_COUNT)(A,F(10));
     CLOSE FILE(CARD_FILE);
     PUT SKIP(2) EDIT('PDSUNLDP V1.2.0 ENDED') (A);

-P100_OPEN_PDS:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_OPEN;
     PDSGET_MEMBER  = 'PDSIN   ';
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
         CALL P200_START_DIR;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('OPEN FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('OPEN FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P100_OPEN_PDS;
-P200_START_DIR:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_START;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
         CALL P300_NEXT_DIR;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('START FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('START FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P200_START_DIR;
-P300_NEXT_DIR:PROC;
     PDSGET_RETURN_CODE = 0;
     DO WHILE(PDSGET_RETURN_CODE = 0);
         PDSGET_REQUEST = PDSGET_REQUEST_NEXT;
         CALL P900_CALL_GETPDSP;
         IF PDSGET_RETURN_CODE = 0 THEN
         DO;
             CALL P400_LOCATE_MEMBER;
             PDSGET_RETURN_CODE = 0;
         END;
         ELSE
         IF PDSGET_RETURN_CODE = 4 THEN
             PUT SKIP(2) LIST('END OF DIRECTORY (RC=4)');
         ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                          'NEXT FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
     END; /* DO UNTIL */
 END P300_NEXT_DIR;
-P400_LOCATE_MEMBER:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_LOCATE;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 0 THEN
     DO;
     /*  PUT SKIP LIST('MEMBER NAME=',PDSGET_MEMBER);  */
         CALL P700_PROCESS_STATS;
         CALL P500_READ_MEMBER;
     END;
     ELSE
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('MEMBER NOT FOUND (RC=4)');
     ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                       'LOCATE FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
 END P400_LOCATE_MEMBER;
-P500_READ_MEMBER:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_READ;
     CALL P900_CALL_GETPDSP;
     WS_MEMBER_COUNT=WS_MEMBER_COUNT+1;
     IF PDSGET_RETURN_CODE = 0 THEN
     DO;
         REC_COUNT=0;
         NAME_WORK=PDSGET_MEMBER;
         NAME_STR='';
         DO CHAR_INDEX=1 TO 8;
             IF NAME_WORK_CHAR(CHAR_INDEX) > ' ' THEN
                 NAME_STR=NAME_STR || NAME_WORK_CHAR(CHAR_INDEX);
         END;
         PUT FILE(CARD_FILE) EDIT('./  ADD NAME=',NAME_STR)
                                 (A);
         IF LENGTH(EXEC_PARM)>0 THEN
            PUT FILE(CARD_FILE) EDIT(',',EXEC_PARM)
                                 (A,A);
         DO WHILE (PDSGET_RETURN_CODE = 0);
            PUT FILE(CARD_FILE) EDIT(PDSGET_RECORD80) (SKIP,A);
            REC_COUNT=REC_COUNT+1;
            CALL P900_CALL_GETPDSP;
         END;
     END;

     IF PDSGET_RETURN_CODE = 4 THEN
         PUT EDIT('END OF MEMBER (RC=4)',REC_COUNT,' RECORDS READ')
                 (X(2),A,F(5),A);
     ELSE
         IF PDSGET_RETURN_CODE = 8 THEN
         DO;
             PUT SKIP LIST(
                       'READ FAILED (RC=8); EXECUTION TERMINATED');
             STOP;
         END;
 END P500_READ_MEMBER;
-P600_CLOSE_PDS:PROC;
     PDSGET_REQUEST = PDSGET_REQUEST_CLOSE;
     CALL P900_CALL_GETPDSP;
     IF PDSGET_RETURN_CODE = 4 THEN
         PUT SKIP LIST('CLOSE FAILED (RC=4)');
     ELSE
     IF PDSGET_RETURN_CODE = 8 THEN
     DO;
         PUT SKIP LIST('CLOSE FAILED (RC=8); EXECUTION TERMINATED');
         STOP;
     END;
 END P600_CLOSE_PDS;
-P700_PROCESS_STATS:PROC;
     DECLARE  DATE_WORK                CHAR(10),
              DATE_CONV                PIC '(7)9BBB',
              TIME_WORK                CHAR(5);

     PDSGET_PTR = ADDR(PDSGET_RECORD80);
     PUT SKIP EDIT(PDSGET_MEMBER,PDS_USER_ID) (A,X(2),A);
     IF PDS_USER_ID = (8)' ' THEN RETURN;

     DC_INPUT_FORMAT =  'YYYYDDD ';
     DATE_CONV       =   PDS_DATE_CREATED;
     DC_INPUT_DATE   =   DATE_CONV;
     DC_OUTPUT_FORMAT = 'YYYYMMDD';
     CALL DATCNVP(DATECNV_PARM);
     PUT EDIT(SUBSTR(DC_OUTPUT_DATE,1,4),'/') (A,A)
             (SUBSTR(DC_OUTPUT_DATE,5,2),'/') (A,A)
             (SUBSTR(DC_OUTPUT_DATE,7,2),' ') (A,A);

     DC_INPUT_FORMAT =  'YYYYDDD ';
     DATE_CONV       =   PDS_DATE_UPDATED;
     DC_INPUT_DATE   =   DATE_CONV;
     DC_OUTPUT_FORMAT = 'YYYYMMDD';
     CALL DATCNVP(DATECNV_PARM);
     PUT EDIT(SUBSTR(DC_OUTPUT_DATE,1,4),'/') (A,A)
             (SUBSTR(DC_OUTPUT_DATE,5,2),'/') (A,A)
             (SUBSTR(DC_OUTPUT_DATE,7,2),' ') (A,A);

     SUBSTR(TIME_WORK,1,2) = PDS_TIME_CONVERSION(PDS_TIME_CHANGED_H);
     SUBSTR(TIME_WORK,3,1) = ':';
     SUBSTR(TIME_WORK,4,2) = PDS_TIME_CONVERSION(PDS_TIME_CHANGED_M);

     PUT EDIT(TIME_WORK) (X(2),A);

 END P700_PROCESS_STATS;
-P900_CALL_GETPDSP:PROC;
     CALL GETPDSP (PDSGET_REQUEST_1,
                   PDSGET_MEMBER_1,
                   PDSGET_RECORD80_1,
                   PDSGET_RETURN_CODE_1);
 END P900_CALL_GETPDSP;

 END PDSUNLD;
                        TTTTTTTTTTTT  EEEEEEEEEEEE   SSSSSSSSSS   TTTTTTTTTTTT   IIIIIIIIII   TTTTTTTTTTTT   2222222222
                       TTTTTTTTTTTT  EEEEEEEEEEEE  SSSSSSSSSSSS  TTTTTTTTTTTT   IIIIIIIIII   TTTTTTTTTTTT  222222222222
                           TT       EE            SS        SS       TT            II            TT       22        22
                          TT       EE            SS                 TT            II            TT                 22
                         TT       EE            SSS                TT            II            TT                 22
                        TT       EEEEEEEE       SSSSSSSSS         TT            II            TT                22
                       TT       EEEEEEEE        SSSSSSSSS        TT            II            TT              22
                      TT       EE                     SSS       TT            II            TT            22
                     TT       EE                      SS       TT            II            TT          22
                    TT       EE            SS        SS       TT            II            TT        22
                   TT       EEEEEEEEEEEE  SSSSSSSSSSSS       TT        IIIIIIIIII        TT       222222222222
                  TT       EEEEEEEEEEEE   SSSSSSSSSS        TT        IIIIIIIIII        TT       222222222222



                    JJJJJJJJJJ        444     555555555555        444     777777777777                 AAAAAAAAAA
                    JJJJJJJJJJ       4444     555555555555       4444     77777777777                 AAAAAAAAAAAA
                        JJ          44 44     55                44 44     77      77                  AA        AA
                        JJ         44  44     55               44  44            77                   AA        AA
                        JJ        44   44     55              44   44           77                    AA        AA
                        JJ       44444444444  555555555      44444444444       77                     AAAAAAAAAAAA
                        JJ      444444444444  5555555555    444444444444       77                     AAAAAAAAAAAA
                        JJ             44              55          44          77                     AA        AA
                  JJ    JJ             44               55         44          77                     AA        AA
                  JJ    JJ             44               55         44          77                     AA        AA
                  JJJJJJJJ             44     555555555555         44          77                     AA        AA
                   JJJJJJ              44     55555555555          44          77                     AA        AA


****A   END   JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547   END   A****
****A   END   JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547   END   A****
****A   END   JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547   END   A****
****A   END   JOB 4547  TESTIT2                         ROOM        9.02.44 AM 06 APR 23  PRINTER1  SYS TK4-  JOB 4547   END   A****
